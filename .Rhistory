binwidth = 0.6,
main = "Histogram for Size",
xlab = "Size",
ylab = "Count",
col = I("black")
)
qplot(egonet$Size,
geom = "histogram",
binwidth = 1,
main = "Histogram for Size",
xlab = "Size",
ylab = "Count",
col = I("black")
)
qplot(egonet$Size,
geom = "histogram",
binwidth = 1,
main = "Degree distribution",
xlab = "Size",
ylab = "Count",
col = I("black")
)
qplot(egonet$Size,
geom = "histogram",
binwidth = 1,
main = "Degree distribution of Punknet",
xlab = "Size",
ylab = "Count",
col = I("black")
)
qplot(egonet$Size,
geom = "histogram",
binwidth = 1,
main = "Size distribution of Punknet",
xlab = "Size",
ylab = "Count",
col = I("black")
)
qplot(egonet$Ties,
geom = "histogram",
binwidth = 1,
main = "Ties distribution of Punknet",
xlab = "Ties",
ylab = "Count",
col = I("black")
)
qplot(egonet$Ties,
geom = "histogram",
binwidth = 1,
main = "Directed Ties distribution of Punknet",
xlab = "Ties",
ylab = "Count",
col = I("black")
)
qplot(egonet$Ties,
geom = "histogram",
binwidth = 1,
main = "Directed ties distribution of Punknet",
xlab = "Ties",
ylab = "Count",
col = I("black")
)
qplot(egonet$Ties,
geom = "histogram",
binwidth = 1,
main = "Distribution of directed ties in Punknet",
xlab = "Ties",
ylab = "Count",
col = I("black")
)
qplot(egonet$Size,
geom = "histogram",
binwidth = 1,
main = "Distribution of size in Punknet",
xlab = "Size",
ylab = "Count",
col = I("black")
)
qplot(egonet$Size,
geom = "histogram",
binwidth = 1,
main = "Distribution of ego size in Punknet",
xlab = "Size",
ylab = "Count",
col = I("black")
)
tibble(fruit)
suppressPackageStartupMessages(library(tidyverse))
library(gapminder)
library(testthat)
(fox <- str_subset(sentences, pattern = "fox"))
str_split(fox, pattern = " ")
tibble(fruit)
tibble(fruit) %>%
separate(fruit, into = c("pre", "post"), sep = " ")
fox %>%
str_replace(patter="fox", replacement = "giraffe")
fruit %>% head
fruit %>%
str_pad(width=7, side="right", pad="$") %>%
head()
str_length(fruit)
length(fruit)
str_length(fruit)
length(fruit) # tells us how many characters in the whole of fruit
str_c(words[1:4], words[5:8], sep=" & ")
words
str_c(words[3:4], words[5:8], sep=" & ")
str_c(words[3:4], words[5:8], sep=" & ", collapse=", ")
str_c(words[1:4], words[5:8], sep=" & ")
str_c(words[3:4], words[5:8], sep=" & ")
str_c(words[1:4], words[5:8], sep=" & ")
str_c(words[3:4], words[5:8], sep=" & ", collapse=", ")
fruit_df <- tibble(
fruit1 = fruit[1:4],
fruit2 = fruit[5:8]
)
fruit_df %>%
unite("flavor_combo", fruit1, fruit2, sep = " & ")
num
?str_pad
(num <- str_pad(c[1:12],3))
(num <- str_pad(1:12],width = 2, side = "left", pad = "0"))
(num <- str_pad(1:12], width = 2, side = "left", pad = "0"))
(num <- str_pad(1:12, width = 2, side = "left", pad = "0"))
(folders <- str_c("/cm1", numb))
(folders <- str_c("/cm1", num))
test_that("folder names are length 5.", {
expect_FILL_THIS_IN()
})
test_that("folder names are length 5.", {
expect_true(all(str_length(folders) == 6))
})
test_that("folder names are length 5.", {
expect_true(all(str_length(folders) == 6))
})
all(str_length(folders) == 6
all(str_length(folders) == 6
all(str_length(folders) == 6
test_that("folder names are length 6.", {
files <- str_c(folders, "README.md")
files <- str_c(folders, "README.md")
(files <- str_c(folders, "README.md"))
contents <- str_c("# Participation\n\n Participation for class meeting", 1:12)
contents
cat(contents)
cat(contents[1])
library(gapminder)
countries <- levels(gapminder$country)
str_subset(countries, pattern = "i.a")
str_view_all(countries, pattern = "i.a")
str_view_all(countries, pattern = "i.a", match=TRUE)
str_view_all(countries, pattern = "a.a.a")
str_view_all(countries, pattern = "a.a.a", match = TRUE)
str_subset(countries, pattern = "a.a.a", match = TRUE)
str_subset(countries, pattern = "a.a.a")
str_view_all_match <- function(countries, pattern) {
str_view_all(countries, pattern, match=TRUE)
}
str_view_all_match(countries, pattern = "i.a")
str_view_all_match(countries, pattern = "\\.")
str_view_all_match(countries, pattern = ["^aeiou"])
str_view_all_match(countries, pattern = "[^aeiou]")
str_view_all_match(countries, pattern = "[^aeiou][^aeiou][^aeiou]")
c("bear", "beer", "bar") %>%
str_view_all_match(pattern = "be(e|a)r")
str_view_all_match(countries, "ro+")
str_view_all_match(countries, "e{2}")
str_view_all_match(countries, pattern="{a|e}{e|a}")
str_view_all_match(countries, pattern="{a|e}|{e|a}")
str_view_all_match(countries, pattern="({a|e})|({e|a})")
str_view_all_match(countries, pattern="(a|e)(a|e)")
str_view_all_match(countries, pattern="(a|e){2}")
str_view_all_match(countries, pattern = "land$")
str_view_all_match(countries, pattern = "$")
str_view_all_match(countries, pattern = "^Ca")
str_view_all_match(countries, "^[^aeiouAEIOU]*$")
str_view_all(c("abad", "abbd"),
pattern="(a)(b)\\1")
str_view_all(c("abad", "abbd"),
pattern="(a)(b)\\2")
str_view_all(c("bananas"), "(.)(.)\\1\\2.*\\1\\2")
str_view_all(c("bananas", "Who can? Bananas can."), "(.)(.)\\1\\2.*\\1\\2")
rm(list=ls())
str_view_all_match <- function(countries, pattern) {
str_view_all(countries, pattern, match=TRUE)
}
str_view_all_match(countries, pattern = "i.a")
---
title: "STAT 547 Class Meeting 02 Worksheet"
output: html_notebook
editor_options:
chunk_output_type: inline
---
```{r}
suppressPackageStartupMessages(library(tidyverse))
library(gapminder)
library(testthat)
```
## Resources
Today's lesson has been drawn from the following resources:
1. Mostly [stat545.com: character data](http://stat545.com/block028_character-data.html)
- See the ["Resources" section](http://stat545.com/block028_character-data.html#resources) for a more comprehensive listing of resources based on the character problem you're facing.
2. [Older stat545 notes](http://stat545.com/block022_regular-expression.html)
3. [r4ds: strings](https://r4ds.had.co.nz/strings.html).
3. [`stringr` vignette](https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html)
## Basic String Manipulation
__Goal__: Go over some basic functionality of `stringr`.
There's that famous sentence about the quick brown fox that contains all letters of the alphabet, although I don't quite remember the sentence. Demo: Check to see if it's in the `sentences` data. Try:
`str_detect(string, pattern)`
`str_subset(string, pattern)`
```{r}
(fox <- str_subset(sentences, pattern = "fox"))
```
Not quite the sentence I was thinking of. How many words does it contain? Use `str_split(string, pattern)`, noting its output (list).
```{r}
str_split(fox, pattern = " ")
```
Exercise: does this sentence contain all letters of the alphabet? Hints:
- Split by `""`.
- Consider putting all in lowercase with `str_to_lower()`.
- Use the base R `table()` function.
```{r}
fox %>%
str_split(fox, pattern = " "[[1]]) %>% length()
str_split(sentences, pattern = "") %>% head()
```
Working in a data frame? `tidyr` has its own version of this. Here's an example from Resource 1, with the fruit data:
```{r}
tibble(fruit)
tibble(fruit) %>%
separate(fruit, into = c("pre", "post"), sep = " ")
```
Demo: we can substitute, too. Replace the word "fox" with "giraffe" using `str_replace(string, pattern, replacement)`:
```{r}
fox %>%
str_replace(patter="fox", replacement = "giraffe")
```
Know the position you want to extract/replace? Try `str_sub()`.
`str_pad()` extends each string to a minimum length:
```{r}
fruit %>% head
fruit %>%
str_pad(width=7, side="right", pad="$") %>%
head()
```
`str_length()` (Not the same as `length()`!)
```{r}
str_length(fruit) # gives # characters in each entry in the vector
length(fruit) # give # characters in the whole of the vector
```
`str_c()` for concatenating strings. Check the docs for an excellent explanation using a matrix.
```{r}
str_c(words[1:4], words[5:8], sep=" & ")
str_c(words[3:4], words[5:8], sep=" & ")
str_c(words[3:4], words[5:8], sep=" & ", collapse=", ")
```
There's a (more limited) `tidyr` version. Straight from Resource 1:
```{r}
fruit_df <- tibble(
fruit1 = fruit[1:4],
fruit2 = fruit[5:8]
)
fruit_df %>%
unite("flavor_combo", fruit1, fruit2, sep = " & ")
```
## Exercise: Populate your Participation Repo
So, you don't want to manually make 12 folders for your participation repo. I hear you. Let's do that by making a character vector with entries `"cm101"`, `"cm102"`, ..., `"cm112"`.
(If you've already done this, it's still a useful exercise!)
### Make Folders
Let's make those folders!
1. Make a character vector with entries `"01"`, `"02"`, ..., `12` with `str_pad()`.
```{r}
(num <- str_pad(1:12, width = 2, side = "left", pad = "0"))
```
2. Use `str_c()` to combine `"/cm1"` with the numbers:
- If your system uses "\" instead of "/", you might need two backslashes.
```{r}
(folders <- str_c("/cm1", num))
```
3. Use `testthat` to check that each entry of `folders` has 6 characters. You might find the base R `all()` function useful.
```{r}
test_that("folder names are length 6.", {
expect_true(all(str_length(folders) == 6))
})
```
4. BONUS: If applicable, make the folders using `dir.create()`.
- Note: `dir.create()` requires the full path to be specified. You might find the `here::here()` function useful.
- This code might work (depending on your directory): `for (folder in folders) dir.create(here::here(folder))`
- We'll learn how to use `purrr` instead of loops next week.
### Make README's
Now, let's seed the folders with README's.
1. Add `/README.md` to the end of the folder names stored in `folders`:
```{r}
(files <- str_c(folders, "README.md"))
```
2. Make a vector of contents to put in each README. Put a title and body.
- Hint: Use `\n` to indicate a new line! This works in graphs, too.
```{r}
contents <- str_c("# Participation\n\n Participation for class meeting", 1:12)
cat(contents[1]) # see what the first entry in the vector looks like
```
3. BONUS: Write the README's to file using base R's `write(x, file)`:
- `for (i in 1:length(files)) write(contents[i], files[i])`
- There's a better alternative to a loop using `purrr`. Next week's topic!
- This code might not work, depending on your workind directory and system.
## Regular Expressions (aka regex)
Great resource is [r4ds](https://r4ds.had.co.nz/strings.html#matching-patterns-with-regular-expressions)!
Premable:
- Useful for identifying _patterns_, not exact character specifications.
- Hard to read and write!
- We'll focus on finding _matches_ (the hardest part). You can also use regex to manipulate strings -- but we'll delegate that to [r4ds: strings: tools](https://r4ds.had.co.nz/strings.html#tools).
Staying true to Resource 1, let's work with the gapminder countries:
```{r}
library(gapminder)
countries <- levels(gapminder$country)
```
### The "any character"
Find all countries in the gapminder data set with the following pattern: "i", followed by any single character, followed by "a":
```{r}
str_subset(countries, pattern = "i.a")
```
Here, `.` stands for "any single character" (or "wildcard").
But, where's Italy? Case-sensitive!
Let's use `str_view_all()` to see the matches:
```{r}
str_view_all(countries, pattern = "i.a")
str_view_all(countries, pattern = "i.a", match=TRUE)
```
Exercise: Canada isn't the only country with three interspersed "a"'s. Find the others. Try both `str_view_all()` and `str_subset()`.
```{r}
str_view_all(countries, pattern = "a.a.a", match = TRUE)
str_subset(countries, pattern = "a.a.a")
```
Let's define a handy function:
```{r}
str_view_all_match <- function(countries, pattern) {
str_view_all(countries, pattern, match=TRUE)
}
str_view_all_match(countries, pattern = "i.a")
```
### The escape
What if I wanted to literally search for countries with a period in the name? Escape with `\`, although R requires a double escape.
```{r}
str_view_all_match(countries, pattern = "\\.")
```
Why does R require a double escape? It does one level of escaping before "executing" the regex.
- See `?Quotes`
- Try searching for "s\. " (without quotes) in this document (don't forget to select "Regex")
### Character Classes
- `[letters]` matches a single character that's either l, e, t, ..., or s.
- `[^letters]`: anything _but_ these letters.
See more at: https://r4ds.had.co.nz/strings.html#character-classes-and-alternatives
Note that not all special characters "work" within `[]`, but some do, and do not always carry the same meaning (like `^`)! From said resource, they are:
>  `$` `.` `|` `?` `*` `+` `(` `)` `[` `{`. Unfortunately, a few characters have special meaning even inside a character class and must be handled with backslash escapes: `]` `\` `^` and `-`.
Exercise: Find all countries with three non-vowels next to each other.
```{r}
str_view_all_match(countries, pattern = "[^aeiou][^aeiou][^aeiou]")
```
### Or
- Use `|` to denote "or".
- "And" is implied otherwise, and has precedence.
- Use parentheses to indicate precedence.
How to find entries of beer or bear?
```{r}
c("bear", "beer", "bar") %>%
str_view_all_match(pattern = "be(e|a)r")
```
### Quantifiers/Repetition
The handy ones are:
- `*` for 0 or more
- `+` for 1 or more
- `?` for 0 or 1
See list at https://r4ds.had.co.nz/strings.html#repetition
Find all countries that have any number of o's (but at least 1) following r:
```{r}
str_view_all_match(countries, "ro+")
```
Find all countries that have exactly two e's next two each other:
```{r}
str_view_all_match(countries, "e{2}")
# could have just put "ee" but this is just to demonstrate {}
```
Exercise: Find all countries that have either "a" or "e", twice in a row (with a changeover allowed, such as "ae" or "ea"):
```{r}
str_view_all_match(countries, pattern="(a|e)(a|e)")
str_view_all_match(countries, pattern="(a|e){2}") # alternative
```
### Position indicators
- `^` corresponds to the __start__ of the line.
- `$` corresponds to the __end__ of the line.
Countries that end in "land":
```{r}
str_view_all_match(countries, pattern = "land$")
str_view_all_match(countries, pattern = "$") # just shows the end
```
Countries that start with "Ca":
```{r}
str_view_all_match(countries, pattern = "^Ca")
```
Countries without a vowel? The word should start with a non-vowel, continue as a non-vowel, and end:
```{r}
str_view_all_match(countries, "^[^aeiouAEIOU]*$")
# * means repeat over and over
```
### Groups
We can refer to parentheses groups:
```{r}
str_view_all(c("abad", "abbd"),
pattern="(a)(b)\\1")
str_view_all(c("abad", "abbd"),
pattern="(a)(b)\\2")
```
Note that the parentheses are first resolved, THEN referred to. NOT re-executed.
```{r}
str_view_all(c("bananas"), "(.)(.)\\1\\2.*\\1\\2")
```
We can refer to them later in the search, too:
```{r}
str_view_all(c("bananas", "Who can? Bananas can."), "(.)(.)\\1\\2.*\\1\\2")
```
test_that("folder names are length 6.", {
expect_true(all(str_length(folders) == 6))
})
(folders <- str_c("/cm1", num))
(num <- str_pad(1:12, width = 2, side = "left", pad = "0"))
(folders <- str_c("/cm1", num))
test_that("folder names are length 6.", {
expect_true(all(str_length(folders) == 6))
})
(files <- str_c(folders, "README.md"))
for (folder in folders) dir.create(here::here(folder))
install.packages("here")
for (folder in folders) dir.create(here::here(folder))
(files <- str_c(folders, "README.md"))
cat(contents[1]) # see what the first entry in the vector looks like
contents <- str_c("# Participation\n\n Participation for class meeting", 1:12)
cat(contents[1]) # see what the first entry in the vector looks like
write(x, file)`:
- `for (i in 1:length(files)) write(contents[i], files[i])
for (i in 1:length(files)) write(contents[i], files[i])
for (i in 1:length(files)) write(contents[i], files[i])
install.packages("here")
content
contents
for (i in 1:length(files)) write(contents[i], files[i])
wd()
is.wd()
getwd()
for (i in 1:length(files)) write(contents[i], files[i])
for (i in 1:length(files)) write(contents[i], files[i])
getwd()
str_view_all(countries, pattern = "i.a", match=TRUE)
library(gapminder)
countries <- levels(gapminder$country)
str_subset(countries, pattern = "i.a")
str_view_all(countries, pattern = "i.a")
str_view_all(countries, pattern = "i.a", match=TRUE)
str_view_all_match(countries, pattern = "i.a")
suppressPackageStartupMessages(library(tidyverse))
library(gapminder)
library(testthat)
suppressPackageStartupMessages(library(tidyverse))
library(gapminder)
library(testthat)
(fox <- str_subset(sentences, pattern = "fox"))
fox
str_split(fox, pattern = " ")
fox %>%
str_split(fox, pattern = " "[[1]]) %>% length()
tibble(fruit) %>%
separate(fruit, into = c("pre", "post"), sep = " ")
tibble(fruit)
tibble(fruit) %>%
separate(fruit, into = c("pre", "post"), sep = " ")
fox %>%
str_replace(patter="fox", replacement = "giraffe")
fruit %>% head
fruit %>%
str_pad(width=7, side="right", pad="$") %>%
head()
str_c(words[1:4], words[5:8], sep=" & ")
str_c(words[3:4], words[5:8], sep=" & ")
str_c(words[3:4], words[5:8], sep=" & ", collapse=", ")
library(gapminder)
countries <- levels(gapminder$country)
str_subset(countries, pattern = "i.a")
str_view_all(countries, pattern = "i.a")
str_view_all(countries, pattern = "i.a", match=TRUE)
(files <- str_c(here::here(folders), "/READ.md"))
for (i in 1:length(files)) write(contents[i], files[i])
(num <- str_pad(1:12, width = 2, side = "left", pad = "0"))
(folders <- str_c("/cm1", num))
(folders <- str_c("/cm0", num))
(folders <- str_c("/cm0", num))
test_that("folder names are length 6.", {
expect_true(all(str_length(folders) == 6))
})
(num <- str_pad(3:12, width = 2, side = "left", pad = "0"))
(folders <- str_c("/cm0", num))
(num <- str_pad(3:14, width = 2, side = "left", pad = "0"))
(folders <- str_c("/cm0", num))
test_that("folder names are length 6.", {
expect_true(all(str_length(folders) == 6))
})
#install.packages("here")
for (folder in folders) dir.create(here::here(folder))
(files <- str_c(folders, "README.md"))
contents <- str_c("# Participation\n\n Participation for class meeting", 3:14)
cat(contents[1]) # see what the first entry in the vector looks like
(files <- str_c(here::here(folders), "/READ.md"))
for (i in 1:length(files)) write(contents[i], files[i])
